import { test, expect } from '@playwright/test';\n\n// Mock ESL story data\nconst MOCK_ESL_STORY = {\n  id: 'esl-story-1',\n  title: 'The Helpful Robot',\n  contentMd: `# The Helpful Robot\n\nIn a busy city, there lived a small robot named Beep. Beep was designed to help people, but he was still learning how to be useful.\n\nOne morning, an old lady named Mrs. Chen dropped her groceries. Apples and oranges rolled everywhere! \"Oh dear,\" she said sadly.\n\nBeep saw what happened. His circuits lit up with an idea. \"I can help!\" he beeped cheerfully.\n\nWith his mechanical arms, Beep carefully picked up each piece of fruit. He even found a lost apple that had rolled under a car.\n\n\"Thank you, little robot,\" Mrs. Chen smiled. \"You are very kind.\"\n\nBeep felt warm inside (well, as warm as a robot can feel). He had learned something important: helping others makes everyone happy, including yourself.\n\nFrom that day on, Beep looked for small ways to help his neighbors every day. Sometimes the smallest acts of kindness make the biggest difference.`,\n  author: 'Community Volunteer',\n  ageRange: '6-8 years',\n  difficulty: 'Easy',\n  wordCount: 156,\n  readingTime: 2,\n  vocabularyWords: [\n    { word: 'circuits', definition: 'electrical pathways inside a machine', difficulty: 'medium' },\n    { word: 'mechanical', definition: 'relating to machines or moving parts', difficulty: 'medium' },\n    { word: 'cheerfully', definition: 'in a happy and positive way', difficulty: 'easy' },\n    { word: 'neighbors', definition: 'people who live nearby', difficulty: 'easy' }\n  ]\n};\n\ntest.describe('Phase 5: ESL Reader Integration Testing', () => {\n  test.beforeEach(async ({ page }) => {\n    // Mock ESL story API\n    await page.route('/api/esl/text-stories/*', route => {\n      const storyId = route.request().url().split('/').pop();\n      \n      if (storyId === MOCK_ESL_STORY.id) {\n        route.fulfill({\n          status: 200,\n          contentType: 'application/json',\n          body: JSON.stringify({\n            success: true,\n            story: MOCK_ESL_STORY\n          })\n        });\n      } else {\n        route.fulfill({ status: 404 });\n      }\n    });\n\n    // Mock vocabulary API\n    await page.route('/api/education/vocabulary', route => {\n      const body = route.request().postDataJSON();\n      const word = body?.word;\n      \n      const vocabWord = MOCK_ESL_STORY.vocabularyWords.find(v => v.word === word);\n      \n      if (vocabWord) {\n        route.fulfill({\n          status: 200,\n          contentType: 'application/json',\n          body: JSON.stringify({\n            success: true,\n            definition: vocabWord.definition,\n            difficulty: vocabWord.difficulty,\n            examples: [`Example sentence with ${word}.`]\n          })\n        });\n      } else {\n        route.fulfill({\n          status: 200,\n          contentType: 'application/json',\n          body: JSON.stringify({\n            success: true,\n            definition: `Definition for ${word}`,\n            difficulty: 'medium'\n          })\n        });\n      }\n    });\n\n    // Mock chatbot API\n    await page.route('/api/education/chatbot', route => {\n      const body = route.request().postDataJSON();\n      const question = body?.question || '';\n      \n      let response = 'I can help you understand this story better!';\n      \n      if (question.toLowerCase().includes('robot')) {\n        response = 'The robot named Beep is the main character. He learns about helping others!';\n      } else if (question.toLowerCase().includes('help')) {\n        response = 'The story teaches us that helping others makes everyone happy, including ourselves.';\n      } else if (question.toLowerCase().includes('moral') || question.toLowerCase().includes('lesson')) {\n        response = 'The moral of the story is that small acts of kindness can make a big difference in the world.';\n      }\n      \n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          success: true,\n          response: response,\n          suggestions: [\n            'What does the robot learn in the story?',\n            'Why is it important to help others?',\n            'What are some ways you can help your neighbors?'\n          ]\n        })\n      });\n    });\n\n    // Mock text adaptation API\n    await page.route('/api/education/adapt-text', route => {\n      const body = route.request().postDataJSON();\n      const level = body?.level || 'medium';\n      \n      let adaptedContent = MOCK_ESL_STORY.contentMd;\n      \n      if (level === 'easy') {\n        adaptedContent = `# The Helpful Robot\n\nThere was a small robot named Beep. Beep wanted to help people.\n\nOne day, an old lady dropped her food. Apples fell on the ground.\n\n\"Oh no!\" she said.\n\nBeep saw this. \"I can help!\" he said.\n\nBeep picked up all the apples. He gave them back to the lady.\n\n\"Thank you!\" she said. \"You are very nice.\"\n\nBeep felt happy. He learned that helping people is good.\n\nNow Beep helps people every day.`;\n      } else if (level === 'hard') {\n        adaptedContent = MOCK_ESL_STORY.contentMd + `\\n\\n## Discussion Questions\n\n1. Analyze the character development of Beep throughout the narrative.\n2. How does the author use anthropomorphism to convey the central theme?\n3. What literary devices are employed to engage the target audience?`;\n      }\n      \n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          success: true,\n          adaptedContent: adaptedContent,\n          level: level\n        })\n      });\n    });\n  });\n\n  test('should load ESL story reader page correctly', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Verify story title and content are displayed\n    await expect(page.locator('h1, .story-title')).toContainText(MOCK_ESL_STORY.title);\n    \n    // Verify story content is rendered\n    const contentArea = page.locator('.story-content, .text-reader, .content, main');\n    await expect(contentArea).toBeVisible();\n    await expect(contentArea).toContainText('Beep');\n  });\n\n  test('should provide word definitions on click/hover', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for clickable words or vocabulary highlights\n    const vocabularyWords = ['circuits', 'mechanical', 'cheerfully', 'neighbors'];\n    \n    for (const word of vocabularyWords) {\n      // Try to find the word in the content\n      const wordElement = page.locator(`text=${word}`).first();\n      \n      if (await wordElement.isVisible()) {\n        // Try clicking on the word\n        await wordElement.click();\n        \n        // Look for definition popup or tooltip\n        const definitionSelectors = [\n          '.definition, .tooltip, .popup, .vocabulary-popup',\n          `text=${MOCK_ESL_STORY.vocabularyWords.find(v => v.word === word)?.definition}`,\n          '.word-definition'\n        ];\n        \n        let definitionShown = false;\n        for (const selector of definitionSelectors) {\n          if (await page.locator(selector).isVisible({ timeout: 2000 })) {\n            definitionShown = true;\n            console.log(`✅ Definition shown for word: ${word}`);\n            break;\n          }\n        }\n        \n        if (!definitionShown) {\n          console.log(`ℹ️  Definition popup not found for: ${word}`);\n        }\n        \n        // Close definition if it appeared\n        await page.keyboard.press('Escape');\n        break; // Test one word to avoid timeout\n      }\n    }\n  });\n\n  test('should integrate AI chatbot for story Q&A', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for chatbot interface\n    const chatbotSelectors = [\n      '.chatbot, .chat-widget, .ai-assistant',\n      'button').filter({ hasText: /chat|ask|help|question/i }),\n      '.chat-interface, .qa-section'\n    ];\n    \n    let chatbotFound = false;\n    let chatInput;\n    let sendButton;\n    \n    for (const selector of chatbotSelectors) {\n      const element = page.locator(selector).first();\n      \n      if (await element.isVisible()) {\n        chatbotFound = true;\n        \n        // If it's a button, click to open chatbot\n        if (selector.includes('button')) {\n          await element.click();\n          await page.waitForTimeout(1000);\n        }\n        \n        // Look for chat input\n        chatInput = page.locator(\n          'input[placeholder*=\"question\" i], textarea[placeholder*=\"ask\" i], .chat-input input, .chat-input textarea'\n        ).first();\n        \n        sendButton = page.locator(\n          'button').filter({ hasText: /send|ask|submit/i })\n        ).first();\n        \n        break;\n      }\n    }\n    \n    if (chatbotFound && await chatInput?.isVisible()) {\n      // Ask a question about the story\n      const testQuestion = 'What does the robot learn in this story?';\n      await chatInput.fill(testQuestion);\n      \n      if (await sendButton?.isVisible()) {\n        await sendButton.click();\n      } else {\n        await chatInput.press('Enter');\n      }\n      \n      // Look for response\n      const responseSelectors = [\n        '.chat-response, .bot-message, .ai-response',\n        'text=/robot.*learn/i',\n        '.message, .response'\n      ];\n      \n      let responseFound = false;\n      for (const selector of responseSelectors) {\n        if (await page.locator(selector).isVisible({ timeout: 5000 })) {\n          responseFound = true;\n          console.log('✅ Chatbot response received');\n          break;\n        }\n      }\n      \n      if (!responseFound) {\n        console.log('ℹ️  Chatbot response not detected');\n      }\n    } else {\n      console.log('ℹ️  Chatbot interface not found');\n    }\n  });\n\n  test('should support vocabulary saving functionality', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for vocabulary/word saving features\n    const vocabSaveSelectors = [\n      '.save-word, .bookmark-word, .vocab-save',\n      'button').filter({ hasText: /save.*word|bookmark|remember/i }),\n      '.vocabulary-bank, .saved-words'\n    ];\n    \n    let vocabSaveFound = false;\n    \n    for (const selector of vocabSaveSelectors) {\n      if (await page.locator(selector).count() > 0) {\n        vocabSaveFound = true;\n        console.log('✅ Vocabulary saving feature detected');\n        break;\n      }\n    }\n    \n    console.log('Vocabulary saving functionality:', vocabSaveFound);\n  });\n\n  test('should adapt text difficulty based on proficiency level', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for difficulty level controls\n    const difficultySelectors = [\n      'select[name*=\"level\"], select[name*=\"difficulty\"]',\n      'button').filter({ hasText: /easy|medium|hard|beginner|advanced/i }),\n      '.difficulty-selector, .level-selector'\n    ];\n    \n    let difficultyControlFound = false;\n    \n    for (const selector of difficultySelectors) {\n      const element = page.locator(selector).first();\n      \n      if (await element.isVisible()) {\n        difficultyControlFound = true;\n        \n        // Try to change difficulty level\n        if (selector.includes('select')) {\n          const options = await element.locator('option').count();\n          if (options > 1) {\n            await element.selectOption({ index: 1 });\n            await page.waitForTimeout(1000);\n            \n            // Check if content adapted\n            const contentArea = page.locator('.story-content, .text-reader, .content');\n            const newContent = await contentArea.textContent();\n            console.log('✅ Difficulty level changed, content adapted');\n          }\n        } else if (selector.includes('button')) {\n          // Click on difficulty button\n          const easyButton = page.locator('button').filter({ hasText: /easy/i }).first();\n          if (await easyButton.isVisible()) {\n            await easyButton.click();\n            await page.waitForTimeout(1000);\n            console.log('✅ Easy difficulty selected');\n          }\n        }\n        break;\n      }\n    }\n    \n    console.log('Difficulty adaptation controls:', difficultyControlFound);\n  });\n\n  test('should track reading progress', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for progress indicators\n    const progressSelectors = [\n      '.progress-bar, .reading-progress',\n      'text=/\\d+%|progress/i',\n      '.completion, .progress-indicator'\n    ];\n    \n    let progressFound = false;\n    \n    for (const selector of progressSelectors) {\n      if (await page.locator(selector).count() > 0) {\n        progressFound = true;\n        console.log('✅ Reading progress tracking detected');\n        break;\n      }\n    }\n    \n    // Simulate reading by scrolling\n    await page.evaluate(() => {\n      window.scrollTo(0, document.body.scrollHeight / 2);\n    });\n    \n    await page.waitForTimeout(1000);\n    \n    await page.evaluate(() => {\n      window.scrollTo(0, document.body.scrollHeight);\n    });\n    \n    await page.waitForTimeout(1000);\n    \n    console.log('Reading progress functionality:', progressFound);\n  });\n\n  test('should provide audio playback for TTS functionality', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for audio/TTS controls\n    const audioSelectors = [\n      'button').filter({ hasText: /play|listen|audio|speak/i }),\n      'audio, .audio-player',\n      '.tts-controls, .speech-controls',\n      '.play-button, .listen-button'\n    ];\n    \n    let audioFound = false;\n    \n    for (const selector of audioSelectors) {\n      const element = page.locator(selector).first();\n      \n      if (await element.isVisible()) {\n        audioFound = true;\n        \n        // Try to interact with audio control\n        if (selector.includes('button')) {\n          await element.click();\n          await page.waitForTimeout(2000);\n          \n          // Look for audio playing indicators\n          const playingIndicators = [\n            '.playing, .audio-playing',\n            'button').filter({ hasText: /pause|stop/i }),\n            'text=/playing|speaking/i'\n          ];\n          \n          let isPlaying = false;\n          for (const indicator of playingIndicators) {\n            if (await page.locator(indicator).count() > 0) {\n              isPlaying = true;\n              break;\n            }\n          }\n          \n          console.log('Audio playback initiated:', isPlaying);\n        }\n        break;\n      }\n    }\n    \n    console.log('TTS/Audio functionality:', audioFound);\n  });\n\n  test('should handle comprehension questions and quizzes', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for quiz or comprehension question elements\n    const quizSelectors = [\n      '.quiz, .questions, .comprehension',\n      'text=/question|quiz/i',\n      '.exercise, .activity',\n      'button').filter({ hasText: /quiz|test|questions/i })\n    ];\n    \n    let quizFound = false;\n    \n    for (const selector of quizSelectors) {\n      const element = page.locator(selector).first();\n      \n      if (await element.isVisible()) {\n        quizFound = true;\n        \n        // If it's a button, click to open quiz\n        if (selector.includes('button')) {\n          await element.click();\n          await page.waitForTimeout(1000);\n        }\n        \n        // Look for question elements\n        const questionElements = page.locator(\n          '.question, .quiz-question, h3, h4'\n        ).filter({ hasText: /\\?/ });\n        \n        const questionCount = await questionElements.count();\n        console.log('Comprehension questions found:', questionCount);\n        break;\n      }\n    }\n    \n    console.log('Quiz/Comprehension functionality:', quizFound);\n  });\n\n  test('should support text highlighting and note-taking', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for highlighting or note-taking features\n    const highlightSelectors = [\n      '.highlight, .annotation, .note',\n      'button').filter({ hasText: /highlight|note|mark/i }),\n      '.text-tools, .reading-tools'\n    ];\n    \n    let highlightFound = false;\n    \n    for (const selector of highlightSelectors) {\n      if (await page.locator(selector).count() > 0) {\n        highlightFound = true;\n        console.log('✅ Text highlighting/annotation features detected');\n        break;\n      }\n    }\n    \n    // Try to select text and see if highlighting options appear\n    const contentArea = page.locator('.story-content, .text-reader, .content').first();\n    if (await contentArea.isVisible()) {\n      // Select some text\n      await contentArea.click();\n      await page.keyboard.press('Control+A');\n      await page.waitForTimeout(500);\n      \n      // Check for context menu or highlighting options\n      const contextMenus = page.locator('.context-menu, .text-menu, .highlight-menu');\n      const hasContextMenu = await contextMenus.count() > 0;\n      \n      console.log('Text selection context menu:', hasContextMenu);\n    }\n    \n    console.log('Text highlighting functionality:', highlightFound);\n  });\n\n  test('should be responsive on mobile devices', async ({ page }) => {\n    // Set mobile viewport\n    await page.setViewportSize({ width: 375, height: 667 });\n    \n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Verify story is readable on mobile\n    await expect(page.locator('h1, .story-title')).toBeVisible();\n    \n    const contentArea = page.locator('.story-content, .text-reader, .content');\n    await expect(contentArea).toBeVisible();\n    \n    // Check if text is properly sized for mobile reading\n    const contentBox = await contentArea.boundingBox();\n    expect(contentBox?.width).toBeLessThanOrEqual(375);\n    \n    // Test mobile-specific interactions\n    // Try tapping on a word for definition\n    const firstParagraph = contentArea.locator('p').first();\n    if (await firstParagraph.isVisible()) {\n      await firstParagraph.tap();\n      await page.waitForTimeout(500);\n    }\n    \n    console.log('✅ Mobile responsive ESL reader verified');\n  });\n\n  test('should handle offline reading capability', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Simulate offline condition\n    await page.context().setOffline(true);\n    \n    // Refresh page to test offline behavior\n    await page.reload();\n    \n    // Look for offline indicator or cached content\n    const offlineIndicators = [\n      'text=/offline/i',\n      'text=/no.*connection/i',\n      '.offline-indicator, .connection-status'\n    ];\n    \n    let offlineHandlingFound = false;\n    for (const selector of offlineIndicators) {\n      if (await page.locator(selector).count() > 0) {\n        offlineHandlingFound = true;\n        break;\n      }\n    }\n    \n    // Re-enable online mode\n    await page.context().setOffline(false);\n    \n    console.log('Offline reading capability:', offlineHandlingFound);\n  });\n\n  test('should integrate with user progress tracking', async ({ page }) => {\n    await page.goto(`/esl/story/${MOCK_ESL_STORY.id}`);\n    await page.waitForLoadState('networkidle');\n    \n    // Look for progress tracking integration\n    const progressSelectors = [\n      '.user-progress, .reading-history',\n      'text=/completed|finished|\\d+%/i',\n      '.achievement, .badge, .reward'\n    ];\n    \n    let progressTrackingFound = false;\n    \n    for (const selector of progressSelectors) {\n      if (await page.locator(selector).count() > 0) {\n        progressTrackingFound = true;\n        console.log('✅ User progress tracking integration detected');\n        break;\n      }\n    }\n    \n    console.log('Progress tracking integration:', progressTrackingFound);\n  });\n});