import { test, expect } from '@playwright/test';\n\n// Mobile device configurations for testing\nconst MOBILE_DEVICES = {\n  'iPhone SE': { width: 375, height: 667 },\n  'iPhone 12': { width: 390, height: 844 },\n  'Samsung Galaxy S21': { width: 384, height: 854 },\n  'iPad Mini': { width: 768, height: 1024 },\n  'Small Mobile': { width: 320, height: 568 }\n};\n\n// Key pages to test for mobile responsiveness\nconst PAGES_TO_TEST = [\n  {\n    path: '/library',\n    name: 'Library Page',\n    criticalElements: ['h1, .title', '.story-card, .book-card', '.search, input[type=\"search\"]']\n  },\n  {\n    path: '/dashboard/volunteer/submit',\n    name: 'Volunteer Submission Page',\n    criticalElements: ['input[name=\"title\"]', 'textarea[name=\"content\"]', 'button[type=\"submit\"]']\n  },\n  {\n    path: '/dashboard/story-manager',\n    name: 'Story Manager Dashboard',\n    criticalElements: ['.submissions, .review', '.status', 'button']\n  },\n  {\n    path: '/esl/story/test-story',\n    name: 'ESL Reader Page',\n    criticalElements: ['.story-content, .text-reader', '.vocabulary, .chatbot']\n  }\n];\n\ntest.describe('Phase 5: Mobile Responsiveness Testing', () => {\n  test.beforeEach(async ({ page }) => {\n    // Mock authentication and data for consistent testing\n    await page.addInitScript(() => {\n      window.localStorage.setItem('next-auth.session-token', 'mock-volunteer-session');\n    });\n    \n    // Mock API responses\n    await page.route('/api/library/text-stories', route => {\n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          success: true,\n          textStories: [\n            {\n              id: 'mobile-test-1',\n              title: 'Mobile Test Story',\n              summary: 'A story for testing mobile responsiveness',\n              author: 'Test Author',\n              wordCount: 250\n            }\n          ]\n        })\n      });\n    });\n    \n    await page.route('/api/esl/text-stories/*', route => {\n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          success: true,\n          story: {\n            id: 'test-story',\n            title: 'Mobile ESL Test Story',\n            contentMd: 'This is a test story for mobile ESL reading.'\n          }\n        })\n      });\n    });\n    \n    await page.route('/api/story-manager/text-submissions*', route => {\n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          success: true,\n          submissions: [\n            {\n              id: 'mobile-test-submission',\n              title: 'Mobile Test Submission',\n              status: 'PENDING',\n              author: { name: 'Mobile Author' }\n            }\n          ]\n        })\n      });\n    });\n  });\n\n  // Test each critical page on different mobile devices\n  Object.entries(MOBILE_DEVICES).forEach(([deviceName, viewport]) => {\n    test.describe(`${deviceName} (${viewport.width}x${viewport.height})`, () => {\n      \n      PAGES_TO_TEST.forEach(pageConfig => {\n        test(`should display ${pageConfig.name} responsively on ${deviceName}`, async ({ page }) => {\n          // Set mobile viewport\n          await page.setViewportSize(viewport);\n          \n          // Navigate to the page\n          await page.goto(pageConfig.path);\n          await page.waitForLoadState('networkidle');\n          \n          // Check that the page loads without horizontal scrolling\n          const bodyWidth = await page.evaluate(() => document.body.scrollWidth);\n          expect(bodyWidth).toBeLessThanOrEqual(viewport.width + 20); // Allow small margin for precision\n          \n          // Verify critical elements are visible and properly sized\n          for (const selector of pageConfig.criticalElements) {\n            const elements = page.locator(selector);\n            const elementCount = await elements.count();\n            \n            if (elementCount > 0) {\n              const firstElement = elements.first();\n              await expect(firstElement).toBeVisible();\n              \n              // Check element fits within viewport\n              const elementBox = await firstElement.boundingBox();\n              if (elementBox) {\n                expect(elementBox.x + elementBox.width).toBeLessThanOrEqual(viewport.width + 10);\n                console.log(`✅ ${selector} properly sized on ${deviceName}`);\n              }\n            }\n          }\n          \n          console.log(`✅ ${pageConfig.name} responsive on ${deviceName}`);\n        });\n      });\n    });\n  });\n\n  test('should handle touch interactions on mobile', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPhone 12']);\n    \n    // Test library page touch interactions\n    await page.goto('/library');\n    await page.waitForLoadState('networkidle');\n    \n    // Test tap on story card\n    const storyCard = page.locator('.story-card, .book-card, .card').first();\n    if (await storyCard.isVisible()) {\n      await storyCard.tap();\n      await page.waitForTimeout(1000);\n      console.log('✅ Touch tap interaction working on story card');\n    }\n    \n    // Test submission form on mobile\n    await page.goto('/dashboard/volunteer/submit');\n    await page.waitForLoadState('networkidle');\n    \n    const titleInput = page.locator('input[name=\"title\"], input[placeholder*=\"title\" i]');\n    if (await titleInput.isVisible()) {\n      await titleInput.tap();\n      await titleInput.fill('Mobile Touch Test Title');\n      \n      const contentArea = page.locator('textarea[name=\"content\"], textarea[placeholder*=\"story\" i]');\n      if (await contentArea.isVisible()) {\n        await contentArea.tap();\n        await contentArea.fill('This is a test of mobile touch input for story content.');\n        \n        console.log('✅ Mobile form input interactions working');\n      }\n    }\n  });\n\n  test('should handle mobile keyboard and input focus', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['Samsung Galaxy S21']);\n    \n    await page.goto('/dashboard/volunteer/submit');\n    await page.waitForLoadState('networkidle');\n    \n    // Test input field focus and typing\n    const titleInput = page.locator('input[name=\"title\"], input[placeholder*=\"title\" i]');\n    if (await titleInput.isVisible()) {\n      await titleInput.focus();\n      await page.keyboard.type('Mobile keyboard test');\n      \n      const inputValue = await titleInput.inputValue();\n      expect(inputValue).toContain('Mobile keyboard test');\n      \n      console.log('✅ Mobile keyboard input working');\n    }\n    \n    // Test tab navigation on mobile\n    await page.keyboard.press('Tab');\n    const focusedElement = page.locator(':focus');\n    await expect(focusedElement).toBeVisible();\n    \n    console.log('✅ Mobile tab navigation working');\n  });\n\n  test('should provide mobile-friendly navigation', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPhone SE']);\n    \n    await page.goto('/dashboard/volunteer');\n    await page.waitForLoadState('networkidle');\n    \n    // Look for mobile navigation patterns\n    const mobileNavElements = [\n      '.mobile-nav, .nav-mobile',\n      '.hamburger, .menu-toggle',\n      '.drawer, .side-nav',\n      'button[aria-label*=\"menu\" i]'\n    ];\n    \n    let mobileNavFound = false;\n    for (const selector of mobileNavElements) {\n      const element = page.locator(selector);\n      if (await element.count() > 0) {\n        mobileNavFound = true;\n        \n        // Try to interact with mobile navigation\n        const firstNav = element.first();\n        if (await firstNav.isVisible()) {\n          await firstNav.tap();\n          await page.waitForTimeout(500);\n          \n          // Check if navigation menu opened\n          const navMenu = page.locator('.nav-menu, .menu, .navigation');\n          const isMenuVisible = await navMenu.count() > 0;\n          \n          console.log('Mobile navigation menu opened:', isMenuVisible);\n        }\n        break;\n      }\n    }\n    \n    console.log('Mobile-friendly navigation found:', mobileNavFound);\n  });\n\n  test('should handle mobile scrolling and content overflow', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['Small Mobile']);\n    \n    // Test library page scrolling\n    await page.goto('/library');\n    await page.waitForLoadState('networkidle');\n    \n    // Check initial scroll position\n    const initialScrollY = await page.evaluate(() => window.scrollY);\n    \n    // Scroll down\n    await page.evaluate(() => window.scrollBy(0, 500));\n    const afterScrollY = await page.evaluate(() => window.scrollY);\n    \n    expect(afterScrollY).toBeGreaterThan(initialScrollY);\n    console.log('✅ Mobile vertical scrolling working');\n    \n    // Check for horizontal overflow (should be minimal)\n    const hasHorizontalScroll = await page.evaluate(() => \n      document.body.scrollWidth > document.body.clientWidth\n    );\n    \n    expect(hasHorizontalScroll).toBe(false);\n    console.log('✅ No unwanted horizontal scrolling');\n  });\n\n  test('should optimize text readability on mobile', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPhone 12']);\n    \n    // Test ESL reader on mobile\n    await page.goto('/esl/story/test-story');\n    await page.waitForLoadState('networkidle');\n    \n    const contentArea = page.locator('.story-content, .text-reader, .content');\n    if (await contentArea.isVisible()) {\n      // Check text size and line height for readability\n      const textStyles = await contentArea.evaluate(element => {\n        const styles = window.getComputedStyle(element);\n        return {\n          fontSize: parseFloat(styles.fontSize),\n          lineHeight: parseFloat(styles.lineHeight),\n          padding: styles.padding\n        };\n      });\n      \n      // Text should be at least 16px on mobile for readability\n      expect(textStyles.fontSize).toBeGreaterThanOrEqual(14);\n      \n      // Line height should provide good readability\n      if (textStyles.lineHeight > 0) {\n        const lineHeightRatio = textStyles.lineHeight / textStyles.fontSize;\n        expect(lineHeightRatio).toBeGreaterThan(1.2);\n      }\n      \n      console.log('✅ Mobile text readability optimized');\n      console.log(`Font size: ${textStyles.fontSize}px, Line height: ${textStyles.lineHeight}px`);\n    }\n  });\n\n  test('should handle mobile viewport meta tag', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPhone 12']);\n    \n    await page.goto('/library');\n    await page.waitForLoadState('networkidle');\n    \n    // Check for proper viewport meta tag\n    const viewportMeta = await page.locator('meta[name=\"viewport\"]').getAttribute('content');\n    \n    if (viewportMeta) {\n      expect(viewportMeta).toContain('width=device-width');\n      expect(viewportMeta).toContain('initial-scale=1');\n      \n      console.log('✅ Proper viewport meta tag found:', viewportMeta);\n    } else {\n      console.log('⚠️  Viewport meta tag not found - may affect mobile display');\n    }\n  });\n\n  test('should provide mobile-optimized buttons and touch targets', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPhone SE']);\n    \n    await page.goto('/dashboard/volunteer/submit');\n    await page.waitForLoadState('networkidle');\n    \n    // Check button sizes for mobile touch targets\n    const buttons = page.locator('button');\n    const buttonCount = await buttons.count();\n    \n    if (buttonCount > 0) {\n      for (let i = 0; i < Math.min(buttonCount, 5); i++) {\n        const button = buttons.nth(i);\n        if (await button.isVisible()) {\n          const buttonBox = await button.boundingBox();\n          \n          if (buttonBox) {\n            // Touch targets should be at least 44x44 pixels (Apple guidelines)\n            const minTouchSize = 35; // Slightly relaxed for testing\n            \n            expect(buttonBox.height).toBeGreaterThanOrEqual(minTouchSize);\n            expect(buttonBox.width).toBeGreaterThanOrEqual(minTouchSize);\n            \n            console.log(`✅ Button ${i} properly sized for touch: ${buttonBox.width}x${buttonBox.height}`);\n          }\n        }\n      }\n    }\n  });\n\n  test('should handle mobile form validation and error messages', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['Samsung Galaxy S21']);\n    \n    await page.goto('/dashboard/volunteer/submit');\n    await page.waitForLoadState('networkidle');\n    \n    // Try to submit empty form to trigger validation\n    const submitButton = page.locator('button[type=\"submit\"], button').filter({ hasText: /submit/i });\n    if (await submitButton.isVisible()) {\n      await submitButton.tap();\n      await page.waitForTimeout(1000);\n      \n      // Look for validation messages\n      const errorMessages = page.locator('.error, .invalid-feedback, [role=\"alert\"]');\n      const errorCount = await errorMessages.count();\n      \n      if (errorCount > 0) {\n        // Check that error messages are visible and readable on mobile\n        const firstError = errorMessages.first();\n        await expect(firstError).toBeVisible();\n        \n        const errorBox = await firstError.boundingBox();\n        if (errorBox) {\n          expect(errorBox.width).toBeLessThanOrEqual(MOBILE_DEVICES['Samsung Galaxy S21'].width);\n          console.log('✅ Mobile form validation messages properly displayed');\n        }\n      }\n    }\n  });\n\n  test('should support mobile-specific gestures and interactions', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPad Mini']);\n    \n    await page.goto('/library');\n    await page.waitForLoadState('networkidle');\n    \n    // Test swipe-like interactions if implemented\n    const storyGrid = page.locator('.stories, .library-content, .grid');\n    if (await storyGrid.isVisible()) {\n      // Simulate touch drag (horizontal swipe)\n      const gridBox = await storyGrid.boundingBox();\n      if (gridBox) {\n        const startX = gridBox.x + 100;\n        const startY = gridBox.y + 100;\n        const endX = startX - 150;\n        \n        await page.mouse.move(startX, startY);\n        await page.mouse.down();\n        await page.mouse.move(endX, startY);\n        await page.mouse.up();\n        \n        await page.waitForTimeout(500);\n        console.log('✅ Mobile swipe gesture simulation completed');\n      }\n    }\n  });\n\n  test('should provide mobile-optimized search and filtering', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPhone 12']);\n    \n    await page.goto('/library');\n    await page.waitForLoadState('networkidle');\n    \n    // Test mobile search functionality\n    const searchInput = page.locator('input[type=\"search\"], input[placeholder*=\"search\" i]');\n    if (await searchInput.isVisible()) {\n      // Check search input is properly sized for mobile\n      const searchBox = await searchInput.boundingBox();\n      if (searchBox) {\n        expect(searchBox.width).toBeGreaterThan(200); // Should be substantial width\n        expect(searchBox.width).toBeLessThanOrEqual(MOBILE_DEVICES['iPhone 12'].width - 40); // Should fit with margins\n        \n        // Test mobile search interaction\n        await searchInput.tap();\n        await searchInput.fill('mobile test search');\n        \n        console.log('✅ Mobile search functionality working');\n      }\n    }\n    \n    // Test mobile filter controls\n    const filterControls = page.locator('select, .filter, .dropdown');\n    const filterCount = await filterControls.count();\n    \n    if (filterCount > 0) {\n      const firstFilter = filterControls.first();\n      if (await firstFilter.isVisible()) {\n        const filterBox = await firstFilter.boundingBox();\n        if (filterBox) {\n          expect(filterBox.height).toBeGreaterThanOrEqual(40); // Should be touch-friendly\n          console.log('✅ Mobile filter controls properly sized');\n        }\n      }\n    }\n  });\n\n  test('should handle mobile performance and loading states', async ({ page }) => {\n    await page.setViewportSize(MOBILE_DEVICES['iPhone SE']);\n    \n    // Monitor page load performance\n    const startTime = Date.now();\n    \n    await page.goto('/library');\n    await page.waitForLoadState('networkidle');\n    \n    const loadTime = Date.now() - startTime;\n    \n    // Page should load reasonably quickly on mobile\n    expect(loadTime).toBeLessThan(10000); // 10 seconds max\n    \n    console.log(`✅ Mobile page load time: ${loadTime}ms`);\n    \n    // Check for loading indicators\n    const loadingElements = page.locator('.loading, .spinner, .skeleton');\n    const hasLoadingStates = await loadingElements.count() > 0;\n    \n    console.log('Mobile loading states implemented:', hasLoadingStates);\n  });\n});